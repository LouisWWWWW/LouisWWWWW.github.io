<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebUploader多文件上传]]></title>
    <url>%2F2019%2F04%2F28%2Fwebuploaderstudy%2F</url>
    <content type="text"><![CDATA[最近同事推荐了一个.Net开源文档框架QuarkDoc,用于团队内部的文档记录和维护。这个项目是作者花两个周末的时间完成的，有点小BUG，功能相对来说还不是那么完善所以有些功能就得另外去实现了，例如文档的附件上传。这个项目采用的wangEditor富文本编辑器插件，但是在使用过程中发现没有上传附件这个功能。开始以为这个编辑器是有上传插件功能的，是文档项目作者没有实现而已。然后就跑去wangEditor官网去文档。官网使用手册中我找到了上传附件这一项，满心欢喜的点开后却给我泼了一盆冷水。官网不建议把附件内容做到富文本编辑器中，因为附件上传后在富文本编辑器中是以链接的形式在编辑器中存在的，之后用户对这个附件删除是难以被监控到的，而且上传多附件难以管理，也不利于文档内容的展示。但是官网提出了一个解决方案，以网易邮箱举例，网易邮箱的附件和邮件文本内容是完全分离开的，这样两者互不干扰，各自进行独立的管理。明白了意图后，我只能单独的重新设计一下这个功能了。于是乎我选择用百度的Webuploader组件来实现这个功能，因为我前端方便比较薄弱，选择一个成熟应用广泛的组件是最好的做法。接下来就准备开发工作了。第一步：官网下载项目包第二步：文档编辑页面中引入CSS和JS12&lt;link href="~/Assets/Style/wangEditor.min.css" rel="stylesheet" /&gt;&lt;link href="~/Assets/Script/plugins/webuploader/webuploader.css" rel="stylesheet" /&gt; 第三步：在页面中合适的地方添加上传附件按钮以及存放文件的列表1234567&lt;div id="uploader" class="nav-link"&gt; &lt;div class="btns"&gt; &lt;div id="picker"&gt;添加附件&lt;/div&gt; &lt;div id="thelist" class="uploader-list"&gt;&lt;/div&gt; &lt;!--用来存放文件信息--&gt; &lt;/div&gt;&lt;/div&gt; 第四部：初始化WebUploader12345678910111213141516171819202122232425262728293031uploader = WebUploader.create(&#123; // 自动上传 auto: true, // swf文件路径 swf: applicationPath + &apos;..\Assets\Script\plugins\webuploader\Uploader.swf&apos;, // 文件接收服务端。 server: applicationPath + &apos;Document/Upload&apos;, // 选择文件的按钮。可选。 // 内部根据当前运行是创建，可能是input元素，也可能是flash. pick: &#123; id: &apos;#picker&apos;, label: &apos;上传附件&apos;, // 是否开启同时选中多个文件的能力 multiple: true &#125;, dupliacate: true, chunked: true,//开始分片上传 chunkSize: 2048000,//每一片的大小 // 不压缩image, 默认如果是jpeg，文件上传前会压缩一把再上传！ resize: false, // 文件数量 fileNumLimit: 6, // 线程数 threads: 1, // 提交的参数 这里的GUID是通过WebUploader.Base.guid()生成的变量，作为这个页面的表示 formData: &#123; guid: GUID &#125; &#125;); 第五：.Net后台处理附件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879[HttpPost]public virtual ActionResult Upload()&#123; Stream stream = null; string fileName = Request[&quot;name&quot;]; string fileRelName = fileName.Substring(0, fileName.LastIndexOf(&apos;.&apos;));//设置临时存放文件夹名称 int index = Convert.ToInt32(Request[&quot;chunk&quot;]);//当前分块序号 var guid = Request[&quot;guid&quot;];//前端传来的GUID号 var dir = Server.MapPath(&quot;~/Upload&quot;);//文件上传目录 dir = Path.Combine(dir, guid);//临时保存分块的目录 if (!System.IO.Directory.Exists(dir)) System.IO.Directory.CreateDirectory(dir); string filePath = Path.Combine(dir, index.ToString());//分块文件名为索引名，更严谨一些可以加上是否存在的判断，防止多线程时并发冲突 var data = Request.Files[&quot;file&quot;];//表单中取得分块文件 stream = data.InputStream; var fileBinary = new byte[stream.Length]; if (data != null)//为null可能是暂停的那一瞬间 &#123; data.SaveAs(filePath); &#125; stream.Close(); return Json(new &#123; success = true &#125;, &quot;text/plain&quot;);&#125; public ActionResult Merge()&#123; FileBusinessService fileBusinessService = new FileBusinessService(); var user = Session[&quot;OS_USER&quot;] as User; var guid = Request[&quot;guid&quot;];//GUID var uploadDir = Server.MapPath(&quot;~/Upload&quot;);//Upload 文件夹 var ext = Path.GetExtension(Request[&quot;fileName&quot;]);//文件后缀 var dir = Path.Combine(uploadDir, guid);//临时文件夹 var files = System.IO.Directory.GetFiles(dir);//获得下面的所有文件 var fileGuid = Guid.NewGuid().ToString(&quot;N&quot;); var newName = fileGuid + ext;//附件新名称 var finalPath = Path.Combine(uploadDir, newName);//最终的文件路径 var relativePath = &quot;/Upload/&quot; + newName;//相对路径 var fs = new FileStream(finalPath, FileMode.Create); long fileSize = 0; foreach (var part in files.OrderBy(x =&gt; x.Length).ThenBy(x =&gt; x))//排一下序，保证从0-N Write &#123; var bytes = System.IO.File.ReadAllBytes(part); fileSize += bytes.Length; fs.Write(bytes, 0, bytes.Length); bytes = null; System.IO.File.Delete(part);//删除分块 &#125; fs.Flush(); fs.Close(); System.IO.Directory.Delete(dir);//删除文件夹 var fileEntity = new DataEntities.Document.File &#123; Id = fileGuid, OriginalName = Request[&quot;fileName&quot;],//原始文件名 NewName = newName,//新文件名 FileType = ext, //文件类型 FileSize = fileSize.ToString(), //文件大小 RelativePath = relativePath, //相对路径 FilePath = finalPath, //绝对路径 CreatedTime = DateTime.Now, LastUpdateTime = DateTime.Now, IsEnabled = true, CustomerId = user.Id &#125;; fileBusinessService.Insert(fileEntity);//记录文件数据 return Json(new &#123; success = true, fileId = fileGuid &#125;);&#125; 第六步：文件的回显以及删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 文件上传成功，给item添加成功class, 用样式标记上传成功。 uploader.on('uploadSuccess', function (file, response) &#123; $('#' + file.id).find('p.state').text('已上传'); $.post(applicationPath + 'Document/Merge', &#123; guid: GUID, fileName: file.name, fileId: file.id &#125;, function (data) &#123; $("#uploader .state").html("上传成功..."); console.log(data.fileId); $("#" + GUID).attr('id', data.fileId); fileIds.push(data.fileId); &#125;); &#125;);// 当有文件被添加进队列的时候 uploader.on('fileQueued', function (file) &#123; console.log(file); if (file.source.id == undefined) &#123; var $li = $( '&lt;li id="' + GUID + '" class="file-item"&gt;' + '&lt;span class="file-name"&gt;' + file.name + '&lt;/span&gt;' + '&lt;span class="file-del" &gt;&lt;img src="../../Assets/Image/delete.png" height="15" width="15" alt=""&gt;&lt;/span&gt;' + '&lt;/li&gt;' ); &#125; else &#123; var $li = $( '&lt;li id="' + file.source.id + '" class="file-item"&gt;' + '&lt;span class="file-name"&gt;' + '&lt;a href="' + "http://"+window.location.host + file.source.ret + '"&gt;' + file.name + '&lt;/a&gt; ' + '&lt;/span&gt;' + '&lt;span class="file-del" &gt;&lt;img src="../../Assets/Image/delete.png" height="15" width="15" alt=""&gt;&lt;/span&gt;' + '&lt;/li&gt;' ); &#125; // $list为容器jQuery实例 $list.append($li); &#125;); $list.on('click', '.file-del', function () &#123; var fileItem = $(this).parent(); var id = $(fileItem).attr("id"); var fileIndex = $(fileItem).index(); $.ajax(&#123; url: 'DeleteFile?fileId=' + id, type: 'GET', // headers: &#123;"Accept": "application/json"&#125;, // contentType: 'application/json;charset=utf-8', success: function (data) &#123; if (data.success) &#123; //uploader实例移除file //uploader.removeFile(id, true); //接收数据移除对应的文件 fileList.splice(fileIndex, 1); $(fileItem).fadeOut(function () &#123; $(fileItem).remove(); &#125;); &#125; else &#123; alert(data.msg); &#125; &#125;, error: function (data) &#123; alert(data.msg); &#125; &#125;); &#125;); 最终效果因为样式还是比较简陋就不好意思展示了。需要提及的是我采用的是自动上传模式，选择附件后便自动请求后台接口。上传成功后通过uploadSuccess事件请求拼接接口用于拼接已上传的切片附件，此时再将文件数据记录到数据库当中，然后返回一个文件Guid作为文件标识。保存文档将提交附件的Guid，将Guid和文档标识ID绑定在一起。下次编辑的时候调用addFile时间将附件回显至页面。]]></content>
      <categories>
        <category>前端插件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客前言]]></title>
    <url>%2F2019%2F04%2F07%2Fpreface%2F</url>
    <content type="text"><![CDATA[为什么你要写博客？–引自知乎陈素封 在写这个博客之前就已经酝酿了好久了，但是个人比较懒而且拖延症比较厉害，一直到现在才有所实施。其实之前大可以在博客园写博客的，但是账号注册一年多了，一篇像样文章没有，大佬倒是关注了不少，收藏夹也收藏了不少技术文章，但是大多也都只是过了下，也没怎么仔细看。看过一部日本电影《盗钥匙的方法》，里面有一句让我很印象深刻的台词，『好不容易稍微有点学习的干劲了，可是书一买回来就满足了，你小子就是那种最渣的人』。当时电影看到这句台词瞬间就中枪了，相信不少人也中枪了，说白了就是懒还喜欢找借口。像我这一类人都有一种特性，就是做件事情都是三分钟热度，在决定做一件事情的时候斗志昂扬，到后面就是全靠脑补了，脑补出目标实现后的美好结果了。例如：看一个技术教程，才看了几篇就在幻想自己要是看完后就怎么怎么样。减肥锻炼身体，锻炼了几天就觉得自己太努力了，就开始幻想再练个把月自己身材就多么多么好。到后面这些事就没坚持下去随便找点借口工作太忙生活太累安慰下自己，甚至最后都忘了这件事了。懒惰是人的一个弱点，许多人做事情就是喜欢先幻想结果半途而废的时候还找一个借口自我安慰，把这个弱点合理化了。之前和老板聊过，我说我需要大量时间，系统学习一下知识这样技术提高比较容易提高。老板笑了笑说，『成年人的时间都是挤出来的，你这么想完全是你在为自己不想学习这件事找借口，你不是想学，而是你根本不想学。』然后说他同学在英伟达，作为一个硬件工程师利用业余时间一个月做出一款安卓APP，现在正在学习人工智能。当时我就无地自容。扯了这么多回到主题，为什么我要写这个博客：1.给自己一个持续的学习动力。 之前没在博客园写博客的一个原因是不太喜欢博客园的一个界面，于是乎花了点时间搭建了一个个人的博客，自定义极强，绑定自己的域名增强自己的归属感。也算是少了一个不写博客的借口。当然如果长时间博客都没更新了，就说明我又自己打自己脸了hhhhh，flag先立好吧。 2.记录自己的成长 记录工作生活当中，比较有意义的知识或者心得。不是单纯为了写而写，只要对自己而言有意义的东西都应该记录下来，也算是一种成长的见证吧。 3.积累知识 写博客本身是需要大量思考的，思考是积累知识的一种过程。当自己对一件事物描述不清楚的时候，或者思考好久也没有答案就说明你还不太了解这个事物，需要到外界寻找答案从而积累知识。当然也不想像一些人的博客一样，文章全是转载的，这样还不如收藏起来或者干脆用自己的话自己的思维方式重新叙述一遍。这样起码是经过你的大脑重新思考过一遍。 最后工作一两年了，感觉自己还是菜鸟一枚，借这个写博客这个机会，好好反思过去哪些事情做得不足，走了哪些弯路，踩过了哪些坑，好好的做一次规划。在目前这样一个充满焦虑的社会，放平心态，做好自己。]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
</search>
